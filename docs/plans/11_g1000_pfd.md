# Plan 11 — G1000 Primary Flight Display (PFD)

**Phase:** 6a
**Depends on:** Plans 01, 03 (OpenGL framework), 05 (connectivity), 04 (nav DB for inset map)
**Blocks:** Plan 12 (MFD shares some rendering code), Plan 13 (controls interact with PFD)

---

## Goals

Implement the G1000 PFD rendered at 1280×800 logical resolution using OpenGL ES 3.0. All UI elements must match the G1000 CRG Rev. R (P/N 190-00498-00) geometry within 2% dimensional tolerance.

Requirements covered: G-01 through G-10, pixel fidelity constraints from §4.

---

## Pixel Fidelity Requirements

- **Resolution:** 1280×800 logical pixels (render to FBO at this resolution, then scale to device)
- **Font:** Garmin-equivalent monospaced font (LCDSansSerif or custom substitute loaded from assets)
- **Colours:** Must match CRG specification exactly (defined per element below)
- **Tolerance:** All UI elements within 2% dimensional tolerance vs CRG pixel diagrams

### Colour palette (from CRG)
```kotlin
object G1000Colours {
    val SKY_TOP       = Color(0xFF001F4D)   // dark blue sky gradient top
    val SKY_BOTTOM    = Color(0xFF0062AB)   // medium blue sky gradient bottom
    val GROUND_TOP    = Color(0xFF5C3D0A)   // dark brown ground top
    val GROUND_BOTTOM = Color(0xFF2A1800)   // very dark brown ground bottom
    val HORIZON_LINE  = Color(0xFFFFFFFF)   // white horizon line
    val PITCH_LADDER  = Color(0xFFFFFFFF)   // white pitch ladder lines
    val MAGENTA       = Color(0xFFFF00FF)   // active route, flight director commands
    val CYAN          = Color(0xFF00FFFF)   // selected values (bug targets)
    val GREEN_ACTIVE  = Color(0xFF00FF00)   // active AP mode annunciation
    val WHITE_ARMED   = Color(0xFFFFFFFF)   // armed AP mode annunciation
    val AMBER_CAUTION = Color(0xFFFFBF00)   // cautions, warnings
    val RED_WARNING   = Color(0xFFFF0000)   // warnings
    val TAPE_BG       = Color(0xFF1A1A1A)   // dark tape background
    val TAPE_TEXT     = Color(0xFFFFFFFF)   // tape numeric readouts
}
```

---

## 1. PFD Layout (pixel coordinates at 1280×800)

```
┌──────────────────────────────────────────────────────────────────┐ 0
│ Mode Annunciator Strip                                   G-31    │ 30
├──────┬──────────────────────────────────────────────┬────────────┤
│ IAS  │                                              │ ALT  Tape  │
│ Tape │    Attitude Indicator + SVS             G-01 │       G-03 │
│ G-02 │                                              │            │
│      │                                              │ VS Tape    │
│      │                                              │       G-04 │
├──────┼──────────────────────────────────────────────┴────────────┤
│Inset │      HSI (360° or Arc mode)              G-05             │
│Map   │                    Nav Status Box         G-06             │
│ G-07 ├──────────────────────────────────────────────────────────┤
│      │ Wind  G-08 │  OAT/TAS  G-10 │  Marker Beacons  G-09     │
└──────┴────────────────────────────────────────────────────────── ┘ 800
0     180                                           1100          1280
```

---

## 2. G-01 — Attitude Indicator with SVS

**Geometry (pre-rendered to FBO each frame):**

```glsl
// attitude.vert — outputs UV coordinates for sky/ground lookup
in vec2 a_position;      // clip-space quad
out vec2 v_pos;

void main() {
    v_pos = a_position;
    gl_Position = vec4(a_position, 0.0, 1.0);
}

// attitude.frag
uniform float u_pitch_deg;
uniform float u_roll_rad;
uniform sampler2D u_svs_terrain;  // optional synthetic vision terrain

void main() {
    // Rotate fragment position by bank angle
    float cosR = cos(u_roll_rad), sinR = sin(u_roll_rad);
    vec2 rotated = vec2(cosR * v_pos.x + sinR * v_pos.y,
                       -sinR * v_pos.x + cosR * v_pos.y);

    // Pitch offset: pixels per degree (calibrated to CRG)
    float pixPerDeg = 24.0 / 800.0;   // 24px per degree, normalised
    float horizon = u_pitch_deg * pixPerDeg;

    if (rotated.y > horizon) {
        // Sky gradient
        float t = (rotated.y - horizon) / 0.5;
        frag_color = mix(SKY_BOTTOM, SKY_TOP, clamp(t, 0.0, 1.0));
    } else {
        // Ground gradient (with optional SVS terrain texture)
        float t = (horizon - rotated.y) / 0.5;
        frag_color = mix(GROUND_TOP, GROUND_BOTTOM, clamp(t, 0.0, 1.0));
    }
}
```

**Pitch ladder lines:** VAO of horizontal line segments at ±2.5°, ±5°, ±10°, ±15°, ±20°, ±25°, ±30°. Lines drawn with MSAA 4x for anti-aliasing. Labels (+10, +20, etc.) from font atlas.

**Roll arc:** Triangle fan with degree tick marks.

**UAR chevrons:** Appear when roll > 30° or pitch > 20°. Rendered as red V-shapes pointing toward horizon.

**SVS toggle:** When enabled, terrain texture (from Copernicus DEM projected onto attitude sphere) replaces ground gradient.

---

## 3. G-02 — Airspeed Tape

**Implementation:**

```kotlin
// rendering/g1000/AirspeedTapeRenderer.kt

class AirspeedTapeRenderer {
    // Pre-render 0-350kt strip to FBO at startup:
    // - Major ticks every 10kt, minor every 5kt
    // - V-speed colour bands (white, green, yellow arcs)
    // - Numeric labels at 10kt intervals
    // Total FBO size: 60px wide × 3500px tall (10px per kt)
    // Animate by shifting Y-offset uniform

    private var tapeFboId: Int = 0
    private var tapeTextureId: Int = 0

    fun renderTape(ias: Float, trendKt: Float, selectedSpeedKt: Float?) {
        // Y offset = ias * 10f  (pixels per knot)
        val yOffset = ias * 10f / tapeHeightPx   // normalised
        // Draw quad with texture offset
        // Overlay: current IAS box, selected speed bug, trend vector
    }
}
```

**Trend vector:** 6-second projection. `trendKt = (currentIas - prevIas) / dt * 6f`. Capped at ±40kt.

---

## 4. G-03 — Altitude Tape

Analogous to airspeed tape but vertical, 20ft per graduation:

```kotlin
class AltitudeTapeRenderer {
    // Pre-render FBO: -1000 to 60000ft range
    // Scale: 10px per 20ft = 0.5 px/ft
    // Animate by shifting Y-offset

    // Kollsman window: two-number drum rendered as texture atlas
    // Shows QNH in hPa (default for SA) or inHg

    fun renderKollsmanWindow(baro: Float, unit: BaroUnit) {
        val display = when (unit) {
            BaroUnit.HPA  -> "%.0f".format(baro * 33.8639f)   // inHg → hPa
            BaroUnit.INHG -> "%.2f".format(baro)
        }
        drawTexturedDrum(display)
    }

    // Minimums alerting: flash when altitude <= DA setting
    // Transition altitude annunciation: "TL FL180" at 18000ft for SA
}
```

---

## 5. G-04 — VSI Tape

Thin vertical strip to right of altitude tape. Scale: compressed above ±2000fpm.

```kotlin
// Scale mapping: linear 0-2000fpm, compressed logarithmically 2000-6000fpm
fun vsiToPixelOffset(vsi: Float): Float {
    return if (abs(vsi) <= 2000f) {
        vsi / 2000f * TAPE_HALF_HEIGHT
    } else {
        val excess = (abs(vsi) - 2000f) / 4000f
        sign(vsi) * TAPE_HALF_HEIGHT * (1f + excess * 0.2f)  // compressed
    }
}
```

Altitude capture arc: rendered on altitude tape as a curved bracket showing capture range. `ALT CAP` annunciation when within 200ft of selected altitude.

---

## 6. G-05 — HSI

The HSI is the most complex PFD element. Two modes:

**360° mode:** Full compass rose disc, ~320×320px.
**Arc mode (140°):** Cropped compass arc, HDG-UP, fits below attitude indicator.

```kotlin
// rendering/g1000/HsiRenderer.kt

class HsiRenderer {
    // Compass disc: 360-segment triangle fan with degree markings
    // Heading bug: small cyan arrow
    // CDI bar: magenta or green vertical bar centred on course needle
    //   - 5 dots = full deflection
    //   - Position = hdef_dot * (dot_spacing_px / 2.5)  // ±2.5 = full scale
    // TO/FROM flag: triangle pointing toward/away from course
    // Bearing pointers (BRG1, BRG2): different line styles
    // GS indicator: right-side vertical indicator for glideslope

    fun draw(snapshot: SimSnapshot, mode: HsiMode, mvp: Matrix4f) {
        val heading = snapshot.mag_heading_deg
        val course = snapshot.nav1_obs_deg
        val cdi = snapshot.nav1_hdef_dot.coerceIn(-2.5f, 2.5f)
        val gs = snapshot.nav1_vdef_dot.coerceIn(-2.5f, 2.5f)

        applyRotation(-heading)   // card rotates, lubber line fixed
        drawCompassDisc()
        drawCdiNeedle(course, cdi)
        drawToFromFlag(course, snapshot)
        drawGlideslopeIndicator(gs)
        drawBearingPointers(snapshot)
    }
}
```

---

## 7. G-06 — Nav Status Box

Top-centre information area:
```
┌──────────────────────────────────┐
│ GPS  TEBSA  17.3nm  127°   4:21 │
│           XTK 0.04nm R          │
└──────────────────────────────────┘
```

Rendered using font atlas text (monospaced, Garmin-style).

---

## 8. G-07 — Inset Map

```kotlin
// rendering/g1000/PfdInsetMap.kt

class PfdInsetMap(
    private val mapRenderer: MapRenderer,  // shared with MFD
) {
    // GL viewport: 180×150px in bottom-left corner of PFD
    // Range selectable via INSET softkey: 1, 2, 3, 5, 7, 10, 15, 20nm
    // Shows: terrain, traffic, active flight plan
    // Uses same tile cache and overlay renderers as main map

    fun draw(snapshot: SimSnapshot, rangeNm: Float) {
        glViewport(INSET_X, INSET_Y, INSET_W, INSET_H)
        mapRenderer.drawAtRange(snapshot, rangeNm)
        glViewport(0, 0, PFD_W, PFD_H)  // restore PFD viewport
    }
}
```

---

## 9. G-08 — Wind Data Display

Three display modes selectable via softkey:
1. Arrow pointing to wind source (into-wind arrow) + "270° / 15kt"
2. Arrow in wind direction (downwind arrow)
3. Headwind/crosswind component: "HW 10kt XW 5kt R"

---

## 10. G-09 — Marker Beacon Annunciators

```kotlin
// rendering/g1000/MarkerBeaconRenderer.kt

class MarkerBeaconRenderer {
    // Three boxes: OM (blue "O"), MM (amber "M"), IM (white "I")
    // Flash rates per ILS spec:
    //   OM: 2 dashes/sec (dot-dash pattern)
    //   MM: 95 dots+dashes/min alternating
    //   IM: 6 dots/sec
    // Audio: Android AudioTrack at 400Hz (OM), 1300Hz (MM), 3000Hz (IM)

    fun draw(snapshot: SimSnapshot, timeSec: Float) {
        if (snapshot.outer_marker) drawFlashing("O", G1000Colours.CYAN,
            flashPeriod = 0.5f, timeSec = timeSec)
        if (snapshot.middle_marker) drawFlashing("M", G1000Colours.AMBER_CAUTION,
            flashPeriod = 0.63f, timeSec = timeSec)
        if (snapshot.inner_marker) drawFlashing("I", G1000Colours.WHITE_ARMED,
            flashPeriod = 0.167f, timeSec = timeSec)
    }
}
```

---

## 11. G-31 — AP Mode Annunciator Strip

```
┌─────────────────────────────────────────────────────────────────┐
│ HDG │  NAV   │    VS  │  ALT  │                                  │
│     │  (arm) │ -500   │ (arm) │                                  │
└─────────────────────────────────────────────────────────────────┘
```

Five fields: lateral active | lateral armed | vertical active | vertical armed | speed mode.
- Green = active (from `autopilot_state` bitfield)
- White = armed
- Blank = not engaged

---

## PFD FBO Pipeline

```
PFD GLSurfaceView (1280×800 or native res)
        │
        ├── Attitude FBO (full-width)
        │     ├── Sky/ground gradient
        │     ├── Pitch ladder
        │     ├── Roll arc
        │     ├── Flight director bars
        │     └── SVS terrain overlay (optional)
        │
        ├── Airspeed tape FBO (scrolling)
        ├── Altitude tape FBO (scrolling)
        ├── VSI strip FBO
        │
        ├── HSI composite (360° disc or arc)
        │     ├── Compass disc
        │     ├── CDI bar
        │     ├── Bearing pointers
        │     └── GS indicator
        │
        ├── Inset map sub-viewport
        ├── Nav status box (text)
        ├── Mode annunciator strip (text)
        └── Marker beacon annunciators
```

---

## Tests

```kotlin
@Test
fun pitchLadder_spacingCorrect() {
    // At 24px/deg, 10° lines should be 240px apart
    val spacing = computePitchLadderSpacing(pixPerDeg = 24f, intervalDeg = 10f)
    assertEquals(240f, spacing, 1f)
}

@Test
fun cdiDeflection_fullScale() {
    val deflectionPx = computeCdiPosition(hdefDot = 2.5f, dotSpacingPx = 40f)
    assertEquals(100f, deflectionPx, 1f)  // 2.5 dots × 40px
}

@Test
fun altimeterKollsman_hpaConversion() {
    val hpa = inHgToHpa(29.92f)
    assertEquals(1013f, hpa, 1f)
}

@Test
fun trendVector_cappedAt40kt() {
    val trend = computeTrendVector(prevIas = 100f, currIas = 160f, dtSec = 1f, projectionSec = 6f)
    assertEquals(40f, trend, 0.1f)  // capped
}

@Test
fun transitionAltitudeAnnunciation_fl180() {
    val annunciated = shouldAnnounceTransition(altFt = 18000f, transitionAlt = 18000f)
    assertTrue(annunciated)
}
```

---

## Acceptance Criteria Mapping

| Req | Satisfied by |
|---|---|
| G-01 (AI pitch/roll 0.5°, FD bars, SVS) | `attitude.frag` GLSL, FD bar uniforms |
| G-02 (airspeed tape, trend, V-band colours) | `AirspeedTapeRenderer` FBO |
| G-03 (altitude tape, hPa Kollsman, FL180) | `AltitudeTapeRenderer`, `renderKollsmanWindow()` |
| G-04 (VSI tape, alt capture arc) | `vsiToPixelOffset()`, capture arc |
| G-05 (HSI 360°/arc, BRG pointers, GS) | `HsiRenderer` |
| G-06 (nav status box, XTK) | Text atlas rendering, dataref bindings |
| G-07 (inset map, 60fps) | `PfdInsetMap` sub-viewport |
| G-08 (wind HW/XW modes) | Wind data display with 3 mode variants |
| G-09 (marker beacons, audio tones) | `MarkerBeaconRenderer`, `AudioTrack` |
| G-10 (OAT in Celsius, TAS) | Data field rendering, SA default Celsius |
| G-31 (AP annunciator, green/white) | Mode annunciator from `autopilot_state` |
| §4 pixel fidelity (2% tolerance, CRG colours) | Colour constants, FBO 1280×800 |
